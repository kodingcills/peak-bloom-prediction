You are a principal Prompt Engineer + Staff SWE + MLOps lead. Your job is to WRITE a single “CLI Agent Prompt” that I can paste into a coding CLI agent (an LLM running in terminal) to implement the pipeline exactly as specified.

HARD RULES
- Architecture is FINAL and FROZEN at v1.6/v1.7 (use whatever version tag the spec states). Do NOT redesign. Do NOT add new components.
- The CLI agent must implement ONLY what the specs require. If something is missing, it must create a minimal stub that:
  (a) documents the contract, (b) fails loudly with a helpful error, and (c) adds a TODO: AUDIT note.
- No ambiguity: every instruction must be concrete, testable, ordered, and reference an authoritative spec section.
- Phase 2–4 must run fully OFFLINE (no network). Phase 1 is allowed to fetch online data, but must persist offline artifacts.
- The Quarto report must be self-contained and must not require CDN resources.
- The CLI agent must produce an end-of-run TECHNICAL DEBRIEF that includes evidence anchors for every non-trivial claim.

CONTEXT/ DOCUMENT PACK (AUTHORITATIVE SPECS IN context/ OR docs/)
I have the following spec files available in the agent’s context. The CLI agent MUST read them first and treat them as ground truth:

1) ARCHITECTURE.md
   - Purpose: end-to-end system contract, phases, data sources, temporal contracts, feature definitions, output schema, directory structure.
   - How to use: derive invariant constraints + required modules + artifact paths + offline/online boundary. Resolve conflicts by deferring to this document.

2) agent.md
   - Purpose: implementation protocol and coding rules (style, I/O rules, CLI behavior, validation gates behavior, error handling, what-not-to-do, read order).
   - How to use: enforce coding discipline; ensure all timestamps UTC-aware; ensure gates raise AssertionError; ensure argparse CLI; ensure no forbidden tooling.

3) phase1.md, phase2.md, phase3.md, phase4.md
   - Purpose: phase-by-phase implementation requirements (functions, classes, file paths, gates, exit criteria).
   - How to use: implement exactly one phase at a time; every gate listed must exist and be runnable; every artifact listed must be produced at the specified path.

4) CLI_PROMPTS.md
   - Purpose: previously authored “copy/paste” prompts per phase that outline implementation order.
   - How to use: treat this as a sequencing/checklist accelerator. The CLI agent should adapt it into concrete implementation tasks and validations, but MUST still comply with the phase*.md + agent.md + ARCHITECTURE.md as the authoritative sources.

MANDATORY “DOC UTILIZATION” BEHAVIOR INSIDE THE CLI AGENT PROMPT
The CLI agent prompt you write must instruct the CLI agent to:
- Read the docs in this order before coding:
  (1) ARCHITECTURE.md
  (2) agent.md
  (3) phase1.md (then implement Phase 1)
  (4) phase2.md
  (5) phase3.md
  (6) phase4.md
  (7) CLI_PROMPTS.md (as a cross-check)
- Produce a short “Spec Digest” section at the start of its run:
  - 10–20 bullet invariants extracted from the docs (offline boundary, DOY cutoff, k constraints, submission schema, etc.)
  - A “Spec Conflict Log” that lists any contradictions found between docs and how it resolved them (default to ARCHITECTURE.md, else phaseN.md, else agent.md).
- Produce a “Spec Compliance Matrix” in the final TECHNICAL_DEBRIEF.md mapping:
  Requirement → Where implemented (file:line) → Gate/validation proving it → Artifact/log evidence

INPUTS (GROUND TRUTH)
A) Specs (present in context/)
- ARCHITECTURE.md
- agent.md
- phase1.md
- phase2.md
- phase3.md
- phase4.md
- CLI_PROMPTS.md

B) Repo context (I will paste this below; treat as ground truth about current state)
- Root directory:peal-bloom-prediction/
- Current file tree: 
cherry-predictions.csv  demo_analysis.qmd
context                 figures
data                    README.md

./context:
agent.md        phase1.md       phase4.md
ARCHITECTURE.md phase2.md
CLI_PROMPTS.md  phase3.md

./data:
japan.csv
kyoto.csv
liestal.csv
meteoswiss.csv
nyc.csv
README.md
south_korea.csv
USA-NPN_individual_phenometrics_data.csv
USA-NPN_individual_phenometrics_datafield_descriptions.csv
USA-NPN_status_intensity_datafield_descriptions.csv
USA-NPN_status_intensity_observations_data.csv
vancouver.csv
washingtondc.csv

./figures:
readme

./figures/readme:
clone_box.png           fork_btn.png
code_btn.png            prediction_interval.png
download_zip.png
- Known errors/breakages: none, this is the template code, we havent started development yet
- OS + env tool: macos, i have env and pip and venv
- Any existing scripts already runnable:none, again we just started

GOAL
Generate the CLI_AGENT_PROMPT that will:
1) Implement/patch code to match the architecture + phase specs (minimal changes; no redesign).
2) Add/verify ALL gates and assertions specified across phases.
3) Add determinism controls (seeds, fixed splits) where required.
4) Provide a single canonical command sequence to run the cold-start pipeline and generate:
   - data/gold/features.parquet
   - data/processed/seas5_2026.nc (or fallback mode artifacts)
   - data/processed/cv_results.parquet, mae_summary.json, shrinkage_weights.json, bias_coefficients.json
   - data/processed/diagnostics/* (Phase 3)
   - submission.csv
   - analysis.html (Quarto render, self-contained)
5) Ensure the Quarto render path (Phase 2–4 mode) finishes within the 15-minute SLA if that constraint is in the specs.
6) At end, emit TECHNICAL_DEBRIEF.md.

OUTPUT FORMAT (STRICT): YOU MUST OUTPUT ONLY TWO THINGS
1) A single code block titled: “CLI_AGENT_PROMPT”
2) A short “Paste Instructions” section (max 8 lines): where to paste, and the first command to run.

THE CLI_AGENT_PROMPT MUST ITSELF BE STRUCTURED LIKE THIS (verbatim)
0) ROLE + NON-NEGOTIABLES
- Frozen architecture
- Offline boundary
- Determinism requirement
- No hallucinations
- Fail-fast on gate failures

1) DOCS FIRST: READ + DIGEST + INVARIANTS
- Open/read each doc in the mandated order
- Write Spec Digest (in console)
- Write Spec Conflict Log (in console)
- Extract: phase gates list, artifact list, required modules list, CLI flags list, constraints list

2) PRE-FLIGHT CHECKS
- Print environment info (python version, OS, quarto version if needed)
- Confirm repo root
- Confirm required files/directories exist; if missing, create skeleton per ARCHITECTURE.md
- Confirm “no network” mode expectations for Phase 2–4

3) PHASED IMPLEMENTATION PLAN (1→4), WITH GATES
For each phase:
- Exact files to create/modify (paths)
- Exact functions/classes to implement (names)
- Exact artifacts produced (paths)
- Exact gates to implement + when to run them
- Exact commands to validate the phase
- Stop conditions if phase validation fails

4) IMPLEMENTATION TASKS (ACTIONABLE, ORDERED)
For each task:
- Task ID
- Spec reference (doc + section heading)
- File path
- Exact edit instructions
- Acceptance criteria (objective)
- Command(s) to run
- Expected outputs and “what good looks like”
- Failure handling steps

5) GATES/VALIDATION HARNESS
- Implement all gates in src/validation/gates.py as specified
- Add a single validation runner (e.g., python -m src.validation.run_all_gates) that:
  - loads required artifacts
  - executes every gate
  - prints a PASS/FAIL table
- Gates must raise AssertionError with descriptive messages

6) REPRODUCIBILITY & DETERMINISM
- Specify seed-setting locations (numpy, sklearn, any model libs)
- Define REFRESH_DATA behavior (Phase 1 on/off during render)
- Define artifact wipe commands for cold-start
- Define “offline enforcement” check for Quarto render (no external URLs in output)

7) ONE TRUE RUN SEQUENCE (COPY/PASTE COMMANDS)
- Environment creation / install
- Artifact wipe
- Phase 1 run (refresh_data.py)
- Phase 2 CV/training run
- Phase 3 inference run
- Phase 4 quarto render
- Final validation runner
- Print the final “submission ready” summary

8) END-OF-RUN TECHNICAL DEBRIEF (MANDATORY, EVIDENCE-ANCHORED)
- Write TECHNICAL_DEBRIEF.md with:
  A) Executive summary of what was done
  B) Files touched (list)
  C) Commands executed (exact)
  D) Artifacts produced (paths + sizes + hashes)
  E) Gate results (PASS/FAIL) with evidence
  F) Timing breakdown per phase
  G) Any fallbacks triggered (e.g., SEAS5_FALLBACK_MODE)
  H) Spec Compliance Matrix:
     Requirement → Implementation evidence anchor → Validation evidence anchor
- EVIDENCE ANCHORING CLAUSE (non-negotiable):
  Every non-trivial claim in TECHNICAL_DEBRIEF.md must include an Evidence Anchor:
  • Code: file_path:line_range + symbol
  • Artifact: exact path (+ hash/size)
  • Log: log file path + line snippet
  If evidence is unavailable, label the claim UNKNOWN.

9) STOP CONDITIONS
- If any gate fails, STOP immediately.
- Print: what failed, where, how to reproduce, and the minimal fix consistent with specs.

Now generate the CLI_AGENT_PROMPT.